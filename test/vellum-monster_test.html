<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>vellum-monster test</title>

    <script src="../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../wct-browser-legacy/browser.js"></script>
    <script src="./custom-assertions.js"></script>

    <script type="module" src="../dist/vellum-monster.js"></script>
  </head>
  <body>

    <test-fixture id="detailed-stat-block">
      <template>

        <vellum-monster
          id="gynosphinx"
          name="Gynosphinx"
          size="large"
          type="monstrosity"
          alignment="lawful neutral"
          ac="17"
          armor="natural armor"
          hit-die="16d10 + 48"
          speeds='["40 ft.", "fly 60 ft."]'

          str="18"
          dex="17"
          con="16"
          int="14"
          wis="11"
          cha="8"

          skills='["Arcana +14", "History +14", "Perception +9", "Religion +9"]'
          vulnerabilities='["fire"]'
          resistances="bludgeoning, piercing, and slashing from nonmagical items"
          immunities='["psychic"]'
          condition-immunities='["charmed", "frightened"]'
          senses='["truesight 120 ft.", "passive Perception 18"]'
          languages='["Common", "Sphinx"]'
          saving-throws='["Strength +14"]'
          traits='[
            {
              "name": "Inscrutable",
              "description": "The sphinx is immune to any effect that would sense its emotions or read its thoughts, as well as any Divination spell that it refuses. Wisdom (Insight) checks made to ascertain the sphinx&apos;s intentions or sincerity have disadvantage."
            },
            {
              "name": "Magic Weapons",
              "description": "The sphinx&apos;s weapon attacks are magical.",
              "hpAdjustment": "+68"
            }
          ]'
          spellcasting='{
            "level": "9th",
            "ability": "Intelligence",
            "save": 17,
            "attackBonus": "+9",
            "notes": " and it requires no material components to cast its spells.",
            "class": "wizard",
            "levels": [
              {
                "level": "Cantrips",
                "spells": ["mage hand", "minor illusion", "prestidigitation"]
              },
              {
                "level": "1st",
                "slots": 4,
                "spells": ["detect magic", "identify", "shield"]
              },
              {
                "level": "2nd",
                "slots": 3,
                "spells": ["darkness", "locate object", "suggestion"]
              },
              {
                "level": "3rd",
                "slots": 3,
                "spells": ["dispel magic", "remove curse", "tongues"]
              },
              {
                "level": "4th",
                "slots": 2,
                "spells": ["banishment", "greater invisibility"]
              },
              {
                "level": "5th",
                "slots": 1,
                "spells": ["legend lore"]
              }
            ]
          }'
          actions='[
            {
              "name": "Multiattack",
              "type": "multiattack",
              "description": "The sphinx makes two claw attacks.",
              "multiAttacks": {
                "id": "claw",
                "number": 2
              }
            },
            {
              "id": "claw",
              "name": "Claw",
              "type": "melee-or-ranged-attack",
              "bonus": "+9",
              "reach": "5 ft.",
              "range": "10ft./20ft.",
              "target": "one target",
              "damage": "2d8 + 4",
              "damageType": "slashing",
              "notes": ". This is a magic weapon attack",
              "limitedUsage": "3/Day",
              "randomEffects": [
                {
                  "roll": "1",
                  "name": "Rabid",
                  "effect": "The target becomes rabid and uses any actions it has this turn to make melee attacks against its nearest ally."
                },
                {
                  "roll": "2",
                  "name": "Paralysed",
                  "effect": "The target becomes paralysed."
                },
                {
                  "roll": "3-5",
                  "name": "Poisoned",
                  "effect": "The target becomes poisoned and takes 1d4 poison damage."
                },
                {
                  "roll": "6",
                  "name": "Blinded",
                  "effect": "The target becomes blinded."
                }
              ]
            },
            {
              "name": "Limited Simple Action",
              "limitedUsage": "1/Day",
              "description": "The sphinx makes one claw attack."
            }
          ]'
          reactions='[
            {
              "name": "Parry",
              "description": "The gynosphinx adds 3 to its AC against one melee attack that would hit it.",
              "acAdjustment": "+1",
              "attackAdjustment": "+1"
            }
          ]'
          legendary-actions='{
            "number": 3,
            "actions": [
              {
                "name": "Claw Attack",
                "description": "The sphinx makes one claw attack.",
                "damageAdjustment": "+39"
              },
              {
                "name": "Teleport",
                "actions": 2,
                "description": "The sphinx magically teleports, along with any equipment it is wearing or carrying, up to 120 feet to an unoccupied space it can see."
              },
              {
                "name": "Cast a Spell",
                "actions": 3,
                "description": "The sphinx casts a spell from its list of prepared Spells, using a spell slot as normal."
              }
            ]
          }'
        >
        </vellum-monster>

      </template>
    </test-fixture>

    <test-fixture id="simple-stat-block">
      <template>

        <vellum-monster
          id="warhorse"
          class="official"
          name="Warhorse"
          size="Large"
          type="beast"
          alignment="unaligned"
          ac="11"
          armor="natural armor"
          hp="11"
          hit-die="16d10 + 48"
          speeds='["60 ft."]'
          cr="½"

          str="18"
          dex="12"
          con="13"
          int="2"
          wis="12"
          cha="7"

          senses='["passive Perception 11"]'
          traits='[
            {
              "name": "Trampling Charge",
              "description": "If the horse moves at least 20 feet straight toward a creature and then hits it with a hooves attack on the same turn, that target must succeed on a DC 14 Strength saving throw or be knocked prone. If the target is prone, the horse can make another attack with its hooves against it as a bonus action."
            }
          ]'
          actions='[
            {
              "name": "Hooves",
              "type": "melee-attack",
              "bonus": "+4",
              "reach": "5ft.",
              "target": "one target",
              "damage": "2d6 + 4",
              "damageType": "bludgeoning"
            }
          ]'
        >
        </vellum-monster>

      </template>
    </test-fixture>

    <test-fixture id="object-stat-block">
      <template>

        <vellum-monster
          id="trench"
          name="Trench"
          size="Huge"
          type="object"
          ac="11"
          hp="40"
          immunities='["poison", "psychic"]'
          threshold="10"

          reactions='[
            {
              "name": "Mire",
              "description": "The trench can grapple anyone attempting to cross it."
            }
          ]'
        >
        </vellum-monster>

      </template>
    </test-fixture>

    <test-fixture id="empty-stat-block">
      <template>

       <vellum-monster id="empty" itemscope itemtype="https://grislyeye.com//vellum-schemas/monster.html">
       </vellum-monster>

      </template>
    </test-fixture>

    <test-fixture id="innate-spellcaster-stat-block">
      <template>

        <vellum-monster
          id="pixie"
          name="Pixie"
          size="Tiny"
          type="fey"
          alignment="neutral good"
          ac="15"
          hp="1"
          hit-die="1d4 - 1"
          speeds='["10 ft.","fly 30 ft."]'

          str="2"
          dex="20"
          con="8"
          int="10"
          wis="14"
          cha="15"

          skills='["Perception +4","Stealth +7"]'
          senses='["passive Perception 11"]'
          traits='[
            {
              "name": "Magic Resistance",
              "description": " The pixie has advantage on saving throws against spells and other magical effects."
            }
          ]'
          spellcasting='{
            "ability": "Charisma",
            "save": 12,
            "innate": true,
            "notes": ". It can innately cast the following spells, requiring only its pixie dust as a component:",
            "levels": [
              {
                "level": "at-will",
                "spells": ["druidcraft"]
              },
              {
                "level": "1/day",
                "spells": ["confusion", "dancing lights", "detect evil and good"]
              }
            ]
          }'
          actions='[
            {
              "name": "Superior Invisibility",
              "description": "The pixie magically turns invisible until its concentration ends (as if concentrating on a spell). Any equipment the pixie wears or carries is invisible with it."
            }
          ]'
        >
        </vellum-monster>

      </template>
    </test-fixture>

    <test-fixture id="named-stat-block">
      <template>

        <vellum-monster
          id="pixie"
          name="Florence the Pixie"
          named="true"
          size="Tiny"
          type="fey"
          alignment="neutral good"
          ac="15"
          hp="1"
          hit-die="1d4 - 1"
          speeds='["10 ft.","fly 30 ft."]'

          str="2"
          dex="20"
          con="8"
          int="10"
          wis="14"
          cha="15"

          skills='["Perception +4","Stealth +7"]'
          senses='["passive Perception 11"]'

          spellcasting='{
            "ability": "Charisma",
            "save": 12,
            "innate": true,
            "notes": ". It can innately cast the following spells, requiring only its pixie dust as a component:",
            "levels": [
              {
                "level": "at-will",
                "spells": ["druidcraft"]
              },
              {
                "level": "1/day",
                "spells": ["confusion", "dancing lights", "detect evil and good"]
              }
            ]
          }'
          legendary-actions='{
            "number": 3,
            "actions": [
              {
                "name": "Claw Attack",
                "description": "The sphinx makes one claw attack.",
                "damageAdjustment": "+39"
              }
            ]
          }'
        >
        </vellum-monster>

      </template>
    </test-fixture>

    <script type="module">
import '../dist/vellum-monster.js'
import { trimAll } from './test-util.js'

suite('<vellum-monster>', () => {

  test('displays name', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      expect(trimAll(element.shadowRoot.textContent)).to.includeOnce('Gynosphinx')
      done()
    })
  })

  test('displays type', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      expect(trimAll(element.shadowRoot.textContent)).to.includeOnce('monstrosity')
      done()
    })
  })

  test('displays size', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      expect(trimAll(element.shadowRoot.textContent)).to.includeOnce('large')
      done()
    })
  })

  test('displays alignment', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      expect(trimAll(element.shadowRoot.textContent)).to.includeOnce('lawful neutral')
      done()
    })
  })

  test('does not display trailing comma after type if alignment not provided', (done) => {
    const element = fixture('object-stat-block')

    flush(() => {
      assert.notInclude(trimAll(element.shadowRoot.textContent), 'object,')
      done()
    })
  })

  test('displays stat name', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const ac = element.shadowRoot.getElementById('ac')
      expect(trimAll(ac.shadowRoot.textContent)).to.includeOnce('Armor Class')
      done()
    })
  })

  test('displays armour class', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const ac = element.shadowRoot.getElementById('ac')
      expect(trimAll(ac.shadowRoot.textContent)).to.includeOnce('17 (natural armor)')
      done()
    })
  })

  test('displays simple armour class', (done) => {
    const element = fixture('simple-stat-block')

    flush(() => {
      const ac = element.shadowRoot.getElementById('ac')
      expect(trimAll(ac.shadowRoot.textContent)).to.includeOnce('11')
      done()
    })
  })

  test('do not display parenthesis for simple armour class', (done) => {
    const element = fixture('simple-stat-block')

    flush(() => {
      const ac = element.shadowRoot.getElementById('ac')
      expect(trimAll(ac.shadowRoot.textContent)).to.not.include('11 ()')
      done()
    })
  })

  test('displays average hit points', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const hitPoints = element.shadowRoot.getElementById('hp')
      expect(trimAll(hitPoints.shadowRoot.textContent)).to.includeOnce(136)
      done()
    })
  })

  test('displays hit points for objects', (done) => {
    const element = fixture('object-stat-block')

    flush(() => {
      const hitPoints = element.shadowRoot.getElementById('hp')
      expect(trimAll(hitPoints.shadowRoot.textContent)).to.includeOnce('40')
      done()
    })
  })

  test('displays override hit points when hit die defined', (done) => {
    const element = fixture('simple-stat-block')

    flush(() => {
      const hitPoints = element.shadowRoot.getElementById('hp')
      expect(trimAll(hitPoints.shadowRoot.textContent)).to.includeOnce('11')
      done()
    })
  })

  test('displays hit die', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const hitPoints = element.shadowRoot.getElementById('hp')
      expect(trimAll(hitPoints.shadowRoot.textContent)).to.includeOnce('16d10 + 48')
      done()
    })
  })

  test('does not display hit die brackets if hie die not provided', (done) => {
    const element = fixture('object-stat-block')

    flush(() => {
      const hitPoints = element.shadowRoot.getElementById('hp')
      assert.notInclude(trimAll(hitPoints.shadowRoot.textContent), '()')
      done()
    })
  })

  test('does not display hit die for empty stat blocks', (done) => {
    const element = fixture('empty-stat-block')

    flush(() => {
      const ac = element.shadowRoot.getElementById('hp')
      expect(trimAll(ac.shadowRoot.textContent)).to.not.include('Hit Points')
      done()
    })
  })

  test('displays speeds', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const speed = element.shadowRoot.getElementById('speed')
      expect(trimAll(speed.shadowRoot.textContent)).to.includeOnce('40 ft., fly 60 ft.')
      done()
    })
  })

  test('displays single speed', (done) => {
    const element = fixture('simple-stat-block')

    flush(() => {
      const speed = element.shadowRoot.getElementById('speed')
      expect(trimAll(speed.shadowRoot.textContent)).to.includeOnce('60 ft.')
      done()
    })
  })

  test('displays strength with bonus', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const abilityScores = element.shadowRoot.querySelector('#ability-scores')
      expect(trimAll(abilityScores.shadowRoot.textContent)).to.includeOnce('18 (+4)')
      done()
    })
  })

  test('displays dexterity with bonus', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const abilityScores = element.shadowRoot.querySelector('#ability-scores')
      expect(trimAll(abilityScores.shadowRoot.textContent)).to.includeOnce('17 (+3)')
      done()
    })
  })

  test('displays constitution with bonus', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const abilityScores = element.shadowRoot.querySelector('#ability-scores')
      expect(trimAll(abilityScores.shadowRoot.textContent)).to.includeOnce('16 (+3)')
      done()
    })
  })

  test('displays intelligence with bonus', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const abilityScores = element.shadowRoot.querySelector('#ability-scores')
      expect(trimAll(abilityScores.shadowRoot.textContent)).to.includeOnce('14 (+2)')
      done()
    })
  })

  test('displays wisdom with bonus', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const abilityScores = element.shadowRoot.querySelector('#ability-scores')
      expect(trimAll(abilityScores.shadowRoot.textContent)).to.includeOnce('11 (+0)')
      done()
    })
  })

  test('displays charisma with bonus', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const abilityScores = element.shadowRoot.querySelector('#ability-scores')
      expect(trimAll(abilityScores.shadowRoot.textContent)).to.includeOnce('8 (-1)')
      done()
    })
  })

  test('does not display abilities table for statblock without abilities', (done) => {
    const element = fixture('object-stat-block')

    flush(() => {
      assert.isNotOk(element.shadowRoot.querySelector('#ability-scores'))
      done()
    })
  })

  test('displays skills', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const skills = element.shadowRoot.getElementById('skills')
      expect(trimAll(skills.shadowRoot.textContent)).to.includeOnce('Arcana +14, History +14, Perception +9, Religion +9')
      done()
    })
  })

  test('do not display skills if monster has no skills', (done) => {
    const element = fixture('simple-stat-block')

    flush(() => {
      const skills = element.shadowRoot.getElementById('skills')
      assert.notInclude(trimAll(skills.shadowRoot.textContent), 'Skills')
      done()
    })
  })

  test('displays damage vulnerabilities', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const vulnerabilities = element.shadowRoot.getElementById('damage-vulnerabilities')
      expect(trimAll(vulnerabilities.shadowRoot.textContent)).to.includeOnce('fire')
      done()
    })
  })

  test('displays damage resistances', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const resistances = element.shadowRoot.getElementById('damage-resistances')
      expect(trimAll(resistances.shadowRoot.textContent)).to.includeOnce('bludgeoning, piercing, and slashing from nonmagical items')
      done()
    })
  })

  test('do not display damage resistances if monster has no damage resistances', (done) => {
    const element = fixture('simple-stat-block')

    flush(() => {
      const resistances = element.shadowRoot.getElementById('damage-resistances')
      expect(trimAll(resistances.shadowRoot.textContent), 'Damage Resistances')
      done()
    })
  })

  test('displays damage immunities', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const immunities = element.shadowRoot.getElementById('damage-immunities')
      expect(trimAll(immunities.shadowRoot.textContent)).to.includeOnce('psychic')
      done()
    })
  })

  test('do not display damage immunities if monster has no damage immunities', (done) => {
    const element = fixture('simple-stat-block')

    flush(() => {
      const immunities = element.shadowRoot.getElementById('damage-immunities')
      expect(trimAll(immunities.shadowRoot.textContent), 'Damage Immunities')
      done()
    })
  })

  test('displays condition immunities', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const immunities = element.shadowRoot.getElementById('condition-immunities')
      expect(trimAll(immunities.shadowRoot.textContent)).to.includeOnce('charmed, frightened')
      done()
    })
  })

  test('do not display condition immunities if monster has no condition immunities', (done) => {
    const element = fixture('simple-stat-block')

    flush(() => {
      const immunities = element.shadowRoot.getElementById('condition-immunities')
      expect(trimAll(immunities.shadowRoot.textContent), 'Condition Immunities')
      done()
    })
  })

  test('displays senses', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const senses = element.shadowRoot.getElementById('senses')
      expect(trimAll(senses.shadowRoot.textContent)).to.includeOnce('truesight 120 ft., passive Perception 18')
      done()
    })
  })

  test('displays languages', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const languages = element.shadowRoot.getElementById('languages')
      expect(trimAll(languages.shadowRoot.textContent)).to.includeOnce('Common, Sphinx')
      done()
    })
  })

  test('do not display languages if monster has no languages', (done) => {
    const element = fixture('simple-stat-block')

    flush(() => {
      const languages = element.shadowRoot.getElementById('languages')
      expect(trimAll(languages.shadowRoot.textContent), 'Languages')
      done()
    })
  })

  test('displays calculated challenge rating', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const challenge = element.shadowRoot.querySelector('#cr')
      expect(trimAll(challenge.shadowRoot.textContent)).to.includeOnce('11 (')
      done()
    })
  })

  test('displays calculated experience points', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const challenge = element.shadowRoot.querySelector('#cr')
      expect(trimAll(challenge.shadowRoot.textContent)).to.includeOnce('(7200 XP)')
      done()
    })
  })

  test('displays default challenge rating', (done) => {
    const element = fixture('simple-stat-block')

    flush(() => {
      const challenge = element.shadowRoot.querySelector('#cr')
      expect(trimAll(challenge.shadowRoot.textContent)).to.includeOnce('½ (')
      done()
    })
  })

  test('displays default experience points', (done) => {
    const element = fixture('simple-stat-block')

    flush(() => {
      const challenge = element.shadowRoot.querySelector('#cr')
      expect(trimAll(challenge.shadowRoot.textContent)).to.includeOnce('(100 XP)')
      done()
    })
  })

  test('does not display challenge rating with XP for objects', (done) => {
    const element = fixture('object-stat-block')

    flush(() => {
      const challenge = element.shadowRoot.querySelector('#cr')
      assert.isNotOk(challenge)
      done()
    })
  })

  test('can calculate CR without an attack', (done) => {
    const element = fixture('innate-spellcaster-stat-block')

    flush(() => {
      const challenge = element.shadowRoot.querySelector('#cr')
      assert.isOk(challenge)
      done()
    })
  })

  test('displays special traits', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const trait = element.shadowRoot.querySelector('#special-trait-1')
      expect(trimAll(trait.shadowRoot.textContent)).to.includeOnce('Magic Weapons. The sphinx\'s weapon attacks are magical.')
      done()
    })
  })

  test('displays single special trait', (done) => {
    const element = fixture('simple-stat-block')

    flush(() => {
      const action = element.shadowRoot.querySelector('#special-trait-0')
      expect(trimAll(action.shadowRoot.textContent)).to.includeOnce('Trampling Charge.')
      done()
    })
  })

  test('displays actions', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const action = element.shadowRoot.querySelector('#multiattack-0')
      expect(trimAll(action.shadowRoot.textContent)).to.includeOnce('Multiattack. The sphinx makes two claw attacks.')
      done()
    })
  })

  test('does not display actions if there are none', (done) => {
    const element = fixture('object-stat-block')

    flush(() => {
      assert.isNotOk(element.shadowRoot.querySelector('#actions'))
      done()
    })
  })

  test('displays attacks', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const attack = element.shadowRoot.querySelector('#attack-1')
      expect(trimAll(attack.shadowRoot.textContent)).to.includeOnce('Claw (3/Day). Melee or Ranged Weapon Attack: +9 to hit, reach 5 ft. or range 10ft./20ft., one target. Hit: 13 (2d8 + 4) slashing damage')
      done()
    })
  })

  test('displays attack notes', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const attack = element.shadowRoot.querySelector('#attack-1')
      expect(trimAll(attack.shadowRoot.textContent)).to.includeOnce('. This is a magic weapon attack.')
      done()
    })
  })

  test('displays random attack effects', (done) => {
    const element = fixture('detailed-stat-block')
    flush(() => {
      const attack = element.shadowRoot.querySelector('#attack-1')
      expect(trimAll(attack.shadowRoot.textContent)).to.includeOnce('2. Paralysed. The target becomes paralysed.')
      done()
    })
  })

  test('displays limited usage for simple action', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const attack = element.shadowRoot.querySelector('#action-2')
      expect(trimAll(attack.shadowRoot.textContent)).to.includeOnce('Limited Simple Action (1/Day).')
      done()
    })
  })

  test('displays single attack', (done) => {
    const element = fixture('simple-stat-block')

    flush(() => {
      const attack = element.shadowRoot.querySelector('#attack-0')
      expect(trimAll(attack.shadowRoot.textContent)).to.includeOnce('Hooves.')
      done()
    })
  })

  test('attack without notes does not display "undefined"', (done) => {
    const element = fixture('simple-stat-block')

    flush(() => {
      const attack = element.shadowRoot.querySelector('#attack-0')
      assert.notInclude(trimAll(attack.shadowRoot.textContent), 'undefined.')
      done()
    })
  })

  test('displays legendary actions for creature with legendary actions', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const lengendaryActions = element.shadowRoot.querySelector('#legendary-actions')
      expect(trimAll(lengendaryActions.shadowRoot.textContent)).to.includeOnce('Legendary Actions')
      done()
    })
  })

  test('does not display legendary actions for creature without legendary actions', (done) => {
    const element = fixture('simple-stat-block')

    flush(() => {
      assert.isNotOk(element.shadowRoot.querySelector('#legendary-actions'))
      done()
    })
  })

  test('displays number of legendary actions', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const lengendaryActions = element.shadowRoot.querySelector('#legendary-actions')
      expect(trimAll(lengendaryActions.textContent)).to.includeOnce('The gynosphinx can take 3 legendary actions')
      done()
    })
  })

  test('displays legendary action with only 1 action cost', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const action = element.shadowRoot.querySelector('#legendary-action-0')
      expect(trimAll(action.shadowRoot.textContent)).to.includeOnce('Claw Attack. The sphinx makes one claw attack.')
      done()
    })
  })

  test('displays legendary action with more than 1 action cost', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const action = element.shadowRoot.querySelector('#legendary-action-2')
      expect(trimAll(action.shadowRoot.textContent)).to.includeOnce('Cast a Spell (Costs 3 Actions). The sphinx casts a spell from its list of prepared Spells, using a spell slot as normal.')
      done()
    })
  })

  test('does not displays "the" in legendary actions for named monster', (done) => {
    const element = fixture('named-stat-block')

    flush(() => {
      const lengendaryActions = element.shadowRoot.querySelector('#legendary-actions')
      assert.notInclude(trimAll(lengendaryActions.textContent), 'The')
      done()
    })
  })

  test('does not lower-case name in legendary actions for named monster', (done) => {
    const element = fixture('named-stat-block')

    flush(() => {
      const lengendaryActions = element.shadowRoot.querySelector('#legendary-actions')
      expect(trimAll(lengendaryActions.textContent)).to.include('Florence the Pixie')
      done()
    })
  })

  test('displays spellcasting for creature with spellcasting', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const spellcasting = element.shadowRoot.querySelector('#spellcasting')
      expect(trimAll(spellcasting.shadowRoot.textContent)).to.includeOnce('Spellcasting')
      done()
    })
  })

  test('does not display spellcasting for creature without spellcasting', (done) => {
    const element = fixture('simple-stat-block')

    flush(() => {
      assert.isNotOk(element.shadowRoot.querySelector('#spellcasting'))
      done()
    })
  })

  test('displays spellcasting level for creature with spellcasting', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const spellcasting = element.shadowRoot.querySelector('#spellcasting')
      expect(trimAll(spellcasting.shadowRoot.textContent)).to.includeOnce('The gynosphinx is a 9th-level spellcaster.')
      done()
    })
  })

  test('displays spellcasting ability for creature with spellcasting', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const spellcasting = element.shadowRoot.querySelector('#spellcasting')
      expect(trimAll(spellcasting.shadowRoot.textContent)).to.includeOnce('Its spellcasting ability is Intelligence')
      done()
    })
  })

  test('displays spell save for creature with spellcasting', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const spellcasting = element.shadowRoot.querySelector('#spellcasting')
      expect(trimAll(spellcasting.shadowRoot.textContent)).to.includeOnce('spell save DC 17')
      done()
    })
  })

  test('displays spell attack bonus for creature with spellcasting', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const spellcasting = element.shadowRoot.querySelector('#spellcasting')
      expect(trimAll(spellcasting.shadowRoot.textContent)).to.includeOnce('+9 to hit with spell attacks')
      done()
    })
  })

  test('displays spell list class for creature with spellcasting', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const spellcasting = element.shadowRoot.querySelector('#spellcasting')
      expect(trimAll(spellcasting.shadowRoot.textContent)).to.includeOnce('The gynosphinx has the following wizard spells prepared:')
      done()
    })
  })

  test('displays spell casting notes for creature with spellcasting', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const spellcasting = element.shadowRoot.querySelector('#spellcasting')
      expect(trimAll(spellcasting.shadowRoot.textContent)).to.includeOnce('and it requires no material components to cast its spells.')
      done()
    })
  })

  test('displays cantrip spells for creature with spellcasting', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const level = element.shadowRoot.querySelector('#spell-level-0')
      expect(trimAll(level.shadowRoot.textContent)).to.includeOnce('Cantrips (at will): mage hand, minor illusion, prestidigitation')
      done()
    })
  })

  test('displays spell and slots for creature with spellcasting', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const level = element.shadowRoot.querySelector('#spell-level-5')
      expect(trimAll(level.shadowRoot.textContent)).to.includeOnce('5th level (1 slot): legend lore')
      done()
    })
  })

  test('does display spellcasting for creature with innate spellcasting', (done) => {
    const element = fixture('innate-spellcaster-stat-block')

    flush(() => {
      const spellcasting = element.shadowRoot.querySelector('#spellcasting')
      expect(trimAll(spellcasting.shadowRoot.textContent)).to.includeOnce('The pixie\'s innate spellcasting ability is Charisma (spell save DC 12). It can innately cast the following spells, requiring only its pixie dust as a component:')
      done()
    })
  })

  test('does not display spellcasting level for creature with innate spellcasting', (done) => {
    const element = fixture('innate-spellcaster-stat-block')

    flush(() => {
      const spellcasting = element.shadowRoot.querySelector('#spellcasting')
      assert.notInclude(trimAll(spellcasting.shadowRoot.textContent), '-level spellcaster.')
      done()
    })
  })

  test('does not display spellcasting attack bonus for creature without spellcasting attack bonus', (done) => {
    const element = fixture('innate-spellcaster-stat-block')

    flush(() => {
      const spellcasting = element.shadowRoot.querySelector('#spellcasting')
      assert.notInclude(spellcasting.shadowRoot.textContent, 'to hit with spell attacks')
      done()
    })
  })

  test('does not display spellcasting spells prepared note for innate spellcasters', (done) => {
    const element = fixture('innate-spellcaster-stat-block')

    flush(() => {
      const spellcasting = element.shadowRoot.querySelector('#spellcasting')
      assert.notInclude(spellcasting.shadowRoot.textContent, 'spells prepared:')
      done()
    })
  })

  test('displays at-will spellcasting level', (done) => {
    const element = fixture('innate-spellcaster-stat-block')

    flush(() => {
      const level = element.shadowRoot.querySelector('#spell-level-0')
      expect(level.shadowRoot.textContent).to.includeOnce('At will:')
      done()
    })
  })

  test('displays once-per-day each spellcasting level', (done) => {
    const element = fixture('innate-spellcaster-stat-block')

    flush(() => {
      const level = element.shadowRoot.querySelector('#spell-level-1')
      expect(level.shadowRoot.textContent).to.includeOnce('1/day each:')
      done()
    })
  })

  test('does not display "the" in spellcasting for named monsters', (done) => {
    const element = fixture('named-stat-block')

    flush(() => {
      const spellcasting = element.shadowRoot.querySelector('#spellcasting')
      assert.notInclude(trimAll(spellcasting.shadowRoot.textContent), 'The')
      done()
    })
  })

  test('does not lower-case name in spellcasting for named monsters', (done) => {
    const element = fixture('named-stat-block')

    flush(() => {
      const spellcasting = element.shadowRoot.querySelector('#spellcasting')
      expect(trimAll(spellcasting.shadowRoot.textContent)).to.include('Florence the Pixie')
      done()
    })
  })

  test('displays reactions', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const reactions = element.shadowRoot.querySelector('#reactions')
      expect(trimAll(reactions.shadowRoot.textContent)).to.includeOnce('Reactions')
      done()
    })
  })

  test('displays reaction name', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const reaction = element.shadowRoot.querySelector('#reaction-0')
      expect(trimAll(reaction.shadowRoot.textContent)).to.includeOnce('Parry.')
      done()
    })
  })

  test('displays reaction description', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const reaction = element.shadowRoot.querySelector('#reaction-0')
      expect(trimAll(reaction.shadowRoot.textContent)).to.includeOnce('The gynosphinx adds 3 to its AC against one melee attack that would hit it.')
      done()
    })
  })

  test('displays saving throws', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      const savingThrows = element.shadowRoot.getElementById('saving-throws')
      expect(trimAll(savingThrows.shadowRoot.textContent)).to.includeOnce('Strength +14')
      done()
    })
  })

  test('does not display saving throws for creature without saving throws', (done) => {
    const element = fixture('simple-stat-block')

    flush(() => {
      const savingThrows = element.shadowRoot.getElementById('saving-throws')
      expect(trimAll(savingThrows.shadowRoot.textContent), 'Saving Throws')
      done()
    })
  })

  test('displays damage threshold for objects', (done) => {
    const element = fixture('object-stat-block')

    flush(() => {
      const threshold = element.shadowRoot.getElementById('damage-threshold')
      expect(trimAll(threshold.shadowRoot.textContent)).to.includeOnce('10')
      done()
    })
  })

  test('calculates effective hit points taking into account hit point adjustments', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      expect(element.effectiveHp).to.equal(204)
      done()
    })
  })

  test('calculates effective AC taking into account AC adjustments', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      expect(element.effectiveAc).to.equal(18)
      done()
    })
  })

  test('calculates max attack bonus', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      expect(element.maxAttackBonus).to.equal(9)
      done()
    })
  })

  test('calculates effective attack bonus taking into account attack bonus adjustments', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      expect(element.effectiveAttackBonus).to.equal(10)
      done()
    })
  })

  test('calculates max damage taking into account multiattacks', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      expect(element.maxDamagePerRound).to.equal(26)
      done()
    })
  })

  test('calculates effective damage taking into account multiattacks and damage adjustments', (done) => {
    const element = fixture('detailed-stat-block')

    flush(() => {
      expect(element.effectiveDamage).to.equal(65)
      done()
    })
  })
})
</script>

  </body>
</html>
